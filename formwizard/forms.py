from django import forms
<<<<<<< HEAD
from django.forms import formsets
import copy

class FormWizard(object):
    """
    The basic FormWizard. This class needs a storage backend when creating
    an instance.
    """

    def __init__(self, storage, form_list, initial_list={}, instance_list={},
        condition_list={}):
        """
        Creates a form wizard instance. `storage` is the storage backend, the
        place where step data and current state of the form gets saved.

        `form_list` is a list of forms. The list entries can be form classes
        of tuples of (`step_name`, `form_class`).

        `initial_list` contains a dictionary of initial data dictionaries.
        The key should be equal to the `step_name` in the `form_list`.

        `instance_list` contains a dictionary of instance objects. This list
        is only used when `ModelForms` are used. The key should be equal to
        the `step_name` in the `form_list`.
        """
        self.form_list = SortedDict()
        self.storage_name = storage

        assert len(form_list) > 0, 'at least one form is needed'

        for i in range(len(form_list)):
            form = form_list[i]
            if isinstance(form, tuple):
                self.form_list[unicode(form[0])] = form[1]
            else:
                self.form_list[unicode(i)] = form

        for form in self.form_list.values():
            if issubclass(form, formsets.BaseFormSet):
                form = form.form
            if [True for f in form.base_fields.values()
                if issubclass(f.__class__, forms.FileField)] and \
                not hasattr(self, 'file_storage'):
                raise NoFileStorageException

        self.initial_list = initial_list
        self.instance_list = instance_list
        self.condition_list = condition_list

    def get_form_list(self, request, storage):
        form_list = SortedDict()
        for form_key, form_class in self.form_list.items():
            condition = self.condition_list.get(form_key, True)
            if callable(condition):
                condition = condition(self, request, storage)
            if condition:
                form_list[form_key] = form_class
        return form_list

    def __repr__(self):
        return '%s: form_list: %s, initial_list: %s' % (
            self.get_wizard_name(), self.form_list, self.initial_list)

    def __call__(self, request, *args, **kwargs):
        """
        This method gets called by the routing engine. The first argument is
        `request` which contains a `HttpRequest` instance. The request is
        stored in `request` for later use.

        After processing the request using the `process_request` method, the
        response gets updated by the storage engine (for example add cookies).
        """

        storage = get_storage(self.storage_name,
            self.get_wizard_name(), request, getattr(self, 'file_storage', None))
        response = self.process_request(request, storage, *args, **kwargs)
        storage.update_response(response)

        if kwargs.get('testmode', False):
            return response, storage
        else:
            return response

    def process_request(self, request, *args, **kwargs):
        """
        Returns a response generated by either `process_get_request` or
        `process_post_request` (depends on `request.method`).
        """
        if request.method == 'GET':
            return self.process_get_request(request, *args, **kwargs)
        else:
            return self.process_post_request(request, *args, **kwargs)

    def process_get_request(self, request, storage, *args, **kwargs):
        """
        If the wizard gets a GET request, it assumes that the user just
        starts at the first step or wants to restart the process. The wizard
        will be resetted before rendering the first step.
        """
        #self.reset_wizard(request, storage)

        if 'extra_context' in kwargs:
            self.update_extra_context(request, storage,
                kwargs['extra_context'])

        storage.set_current_step(self.get_first_step(request, storage))
	return self.render(request, storage, self.get_form(request, storage, data=storage.get_step_data(self.determine_step(request, storage))))

    def process_post_request(self, request, storage, *args, **kwargs):
        """
        Generates a HttpResponse which contains either the current step (if
        form validation wasn't successful), the next step (if the current step
        was stored successful) or the done view (if no more steps are
        available)
        """
        if 'extra_context' in kwargs:
            self.update_extra_context(request, storage,
                kwargs['extra_context'])

        if request.POST.has_key('form_prev_step') and \
            self.get_form_list(request, storage).has_key(
            request.POST['form_prev_step']):
            storage.set_current_step(request.POST['form_prev_step'])
            form = self.get_form(request, storage, 
                data=storage.get_step_data(
                    self.determine_step(request, storage)),
                files=storage.get_step_files(
                    self.determine_step(request, storage)),
            )
        else:
            # Check if form was refreshed
            current_step = self.determine_step(request, storage)
            prev_step = self.get_prev_step(request, storage, step=current_step)
            for value in request.POST:
                if prev_step and not value.startswith(current_step) and value.startswith(prev_step):
                    # form refreshed, change current step
                    storage.set_current_step(prev_step)
                    break

            form = self.get_form(request, storage, data=request.POST,
                files=request.FILES)
            if form.is_valid():
                storage.set_step_data(self.determine_step(request, storage),
                    self.process_step(request, storage, form))
                storage.set_step_files(self.determine_step(request, storage),
                    self.process_step_files(request, storage, form))

                current_step = self.determine_step(request, storage)
                last_step = self.get_last_step(request, storage)

                if current_step == last_step:
                    return self.render_done(request, storage, form, **kwargs)
                else:
                    return self.render_next_step(request, storage, form)

        return self.render(request, storage, form)

    def render_next_step(self, request, storage, form, **kwargs):
        """
        Gets called when the next step/form should be rendered. `form`
        contains the last/current form.
        """
        next_step = self.get_next_step(request, storage)
        new_form = self.get_form(request, storage, next_step,
            data=storage.get_step_data(next_step),
            files=storage.get_step_files(next_step))
        storage.set_current_step(next_step)
        return self.render(request, storage, new_form, **kwargs)

    def render_done(self, request, storage, form, **kwargs):
        """
        Gets called when all forms passed. The method should also re-validate
        all steps to prevent manipulation. If any form don't validate,
        `render_revalidation_failure` should get called. If everything is fine
        call `done`.
        """
        final_form_list = []
        for form_key in self.get_form_list(request, storage).keys():
            form_obj = self.get_form(request, storage, step=form_key,
                data=storage.get_step_data(form_key),
                files=storage.get_step_files(form_key))
            if not form_obj.is_valid():
                return self.render_revalidation_failure(request, storage,
                    form_key, form_obj, **kwargs)
            final_form_list.append(form_obj)
        done_response = self.done(request, storage, final_form_list, **kwargs)
        #self.reset_wizard(request, storage)
        return done_response

    def get_form_prefix(self, request, storage, step=None, form=None):
        """
        Returns the prefix which will be used when calling the actual form for
        the given step. `step` contains the step-name, `form` the form which
        will be called with the returned prefix.

        If no step is given, the form_prefix will determine the current step
        automatically.
        """
        if step is None:
            step = self.determine_step(request, storage)
        return str(step)

    def get_form_initial(self, request, storage, step):
        """
        Returns a dictionary which will be passed to the form for `step` 
        as `initial`. If no initial data was provied while initializing the
        form wizard, a empty dictionary will be returned.
        """
        return self.initial_list.get(step, {})

    def get_form_instance(self, request, storage, step):
        """
        Returns a object which will be passed to the form for `step` 
        as `instance`. If no instance object was provied while initializing
        the form wizard, None be returned.
        """
        return self.instance_list.get(step, None)

    def get_form(self, request, storage, step=None, data=None, files=None):
        """
        Constructs the form for a given `step`. If no `step` is defined, the
        current step will be determined automatically.

        The form will be initialized using the `data` argument to prefill the
        new form.
        """
        if step is None:
            step = self.determine_step(request, storage)
        kwargs = {
            'data': data,
            'files': files,
            'prefix': self.get_form_prefix(request, storage, step,
                self.form_list[step]),
            'initial': self.get_form_initial(request, storage, step),
        }
        if issubclass(self.form_list[step], forms.ModelForm):
            kwargs.update({'instance':
                self.get_form_instance(request, storage, step)})
        elif issubclass(self.form_list[step], forms.models.BaseModelFormSet):
            kwargs.update({'queryset':
                self.get_form_instance(request, storage, step)})
        return self.form_list[step](**kwargs)

    def process_step(self, request, storage, form):
        """
        This method is used to postprocess the form data. For example, this
        could be used to conditionally skip steps if a special field is
        checked. By default, it returns the raw `form.data` dictionary.
        """
        return self.get_form_step_data(request, storage, form)

    def process_step_files(self, request, storage, form):
        return self.get_form_step_files(request, storage, form)

    def render_revalidation_failure(self, request, storage, step, form, **kwargs):
        """
        Gets called when a form doesn't validate before rendering the done
        view. By default, it resets the current step to the first failing
        form and renders the form.
        """
        storage.set_current_step(step)
        return self.render(request, storage, form, **kwargs)

    def get_form_step_data(self, request, storage, form):
        """
        Is used to return the raw form data. You may use this method to
        manipulate the data.
        """
        return form.data

    def get_form_step_files(self, request, storage, form):
        """
        Is used to return the raw form files. You may use this method to
        manipulate the data.
        """
        return form.files

    def get_all_cleaned_data(self, request, storage):
        """
        Returns a merged dictionary of all step' cleaned_data dictionaries.
        If a step contains a `FormSet`, the key will be prefixed with formset
        and contain a list of the formset' cleaned_data dictionaries.
        """
        cleaned_dict = {}
        for form_key in self.get_form_list(request, storage).keys():
            form_obj = self.get_form(request, storage, step=form_key,
                data=storage.get_step_data(form_key),
                files=storage.get_step_files(form_key))
            if form_obj.is_valid():
                if isinstance(form_obj.cleaned_data, list):
                    cleaned_dict.update({
                        'formset-%s' % form_key: form_obj.cleaned_data
                    })
                else:
                    cleaned_dict.update(form_obj.cleaned_data)
        return cleaned_dict

    def get_cleaned_data_for_step(self, request, storage, step):
        """
        Returns the cleaned data for a given `step`. Before returning the
        cleaned data, the stored values are being revalidated through the
        form. If the data doesn't validate, None will be returned.
        """
        if self.form_list.has_key(step):
            form_obj = self.get_form(request, storage, step=step,
                data=storage.get_step_data(step),
                files=storage.get_step_files(step))
            if form_obj.is_valid():
                return form_obj.cleaned_data
        return None

    def determine_step(self, request, storage):
        """
        Returns the current step. If no current step is stored in the storage
        backend, the first step will be returned.
        """
        return storage.get_current_step() or \
            self.get_first_step(request, storage)

    def get_first_step(self, request, storage):
        """
        Returns the name of the first step.
        """
        return self.get_form_list(request, storage).keys()[0]

    def get_last_step(self, request, storage):
        """
        Returns the name of the last step.
        """
        return self.get_form_list(request, storage).keys()[-1]

    def get_next_step(self, request, storage, step=None):
        """
        Returns the next step after the given `step`. If no more steps are
        available, None will be returned. If the `step` argument is None, the
        current step will be determined automatically.
        """
        form_list = self.get_form_list(request, storage)
=======
>>>>>>> upstream/master


class ManagementForm(forms.Form):
    """
    ``ManagementForm`` is used to keep track of the current wizard step.
    """
    current_step = forms.CharField(widget=forms.HiddenInput)
